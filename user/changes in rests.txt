=================== search query ===========================
function searchRestaurants(name) {
    return [
        {
            $match: {
                $and: [
                    {
                        $or: [{
                            name: { $regex: '^' + name, $options: 'i' }
                        },
                        {
                            cuisinOffered: { $elemMatch: { $regex: '^' + name, $options: 'i' } }
                        }]
                    },
                    {
                        status: 'ACTIVE'
                    }
                ]

            }
        },
        /*{
            $lookup: {
                foreignField: '_id',
                localField: 'reviews',
                from: schmaName.reviews,
                as: 'reviews_details'
            }
        },
        {
            $match: {
                'reviews_details.status': {
                    $eq: 'ACTIVE'
                }
            }
        },
        {
            $addFields: {
                "ratings": { $avg: '$reviews_details.rating' },
            }
        },*/
        {
            $group: {
                _id: {
                    'restId': '$_id',
                    name: '$name',
                    cuisins: '$cuisinOffered',
                    location: '$location',
                    reviews: '$reviews',
                    //reviews: '$reviews_details',
                    //ratings: '$ratings'
                }
            }
        }

    ]
}
==================== search restaurant ===========================

function searchRestaurants(req, res) {
    let search = req.params.name
    let sortBy = req.query.sortBy

    return restModel.aggregate(mongoQuery.searchRestaurants(search), (err, response) => {
        if (err) {
            res.json({ code: code.internalError, message: msg.internalServerError })
        }
        else {
            let obj = util.decodeToken(req.headers['authorization'])
            userModel.findOne({ _id: obj.id }).select('location').exec((err, loc) => {
                if (err) {
                    res.json({ code: code.internalError, message: msg.internalServerError })
                }
                else if (loc) {
                    var final = new Promise((resolve, reject) => {
                        response.map(async function (data) {
                            data._id.distance = util.calculateDistance(loc.location.coordinates[1], loc.location.coordinates[0],
                                data._id.location.coordinates[1], data._id.location.coordinates[0], "K") * 1000;
                            var totalRatings = 0;
                            await reviewModel.find({ _id: { $in: data._id.reviews } }).select('status rating').then((rv) => {
                                data._id.reviews = rv
                            }).catch(err => {
                                reject(res.json({ code: code.internalError, message: msg.internalServerError }))
                            })
                            let reviews_details = data._id.reviews.filter(function (result) {
                                if (result.status == status.active) {
                                    totalRatings += result.rating
                                    return result
                                }
                            })
                            if (reviews_details.length > 0) {
                                data._id.ratings = totalRatings / reviews_details.length
                            }
                            else {
                                data._id.ratings = 0
                            }
                            delete data._id.location;
                            delete data._id.reviews;
                            resolve (data);
                        })
                    })
                    // final.then(data => {
                    //     if (sortBy) {
                    //         console.log("data",data)
                    //         data.sort((a, b) => {
                    //             return (b._id[sortBy] - a._id[sortBy])
                    //         })
                    //     }
                    //     res.json({ code: code.ok, message: msg.ok, data: data })
                    // })

                }
            })
        }
    })
}



=================================== filter query ==================================

function filterRestaurant(data, flag) {
    
    if (flag == true) {
        console.log(data)
        return [
            {
                $match: {
                    $and: [
                        {
                            $or: [
                                { mealOffers: data.meal },
                                { mealOffers: 'ALL' }
                            ]
                        },
                        {
                            cuisinOffered: { $in: data.cuisins },
                            perPersonCost: { $gte: data.minBudget, $lte: data.maxBudget },
                            status: 'ACTIVE'
                        }
                    ]
                }
            },
            // {
            //     $lookup: {
            //         foreignField: '_id',
            //         localField: 'reviews',
            //         from: schmaName.reviews,
            //         as: 'reviews_details'
            //     }
            // },
            {
                $group: {
                    _id: {
                        'restId': '$_id',
                        name: '$name',
                        cuisins: '$cuisinOffered',
                        location: '$location',
                        reviews: '$reviews'
                    }
                }
            }
        ]
    }
    else {
        return [
            {
                $match: {
                    $and: [
                        {
                            $or: [
                                { mealOffers: data.meal },
                                { mealOffers: 'ALL' }
                            ]
                        },
                        {
                            cuisinOffered: { $in: data.cuisins },
                            perPersonCost: { $gte: data.minBudget },
                            status: 'ACTIVE'
                        }
                    ]
                }
            },
            // {
            //     $lookup: {
            //         foreignField: '_id',
            //         localField: 'reviews',
            //         from: schmaName.reviews,
            //         as: 'reviews_details'
            //     }
            // },
            {
                $group: {
                    _id: {
                        'restId': '$_id',
                        name: '$name',
                        cuisins: '$cuisinOffered',
                        location: '$location',
                        reviews: '$reviews'
                    }
                }
            }
        ]
    }
}

====================== filter function =======================

function filterRestaurants(req, res) {
    let data = req.body, flag = false
    if (data.maxBudget) {
        flag = true;
    }
    restModel.aggregate(mongoQuery.filterRestaurant(data, flag), async (err, response) => {
        if (err) {
            return res.json({ code: code.internalError, message: msg.internalServerError })
        }
        else {
            let obj = util.decodeToken(req.headers['authorization']);
            await userModel.findOne({ _id: obj.id }).select('location').exec(async (err, loc) => {
                if (err) {
                    return res.json({ code: code.internalError, message: msg.internalServerError })
                }
                else if (loc) {
                    let final = new Promise((resolve, reject) => {
                        response.map(async function (data) {
                            data._id.distance = util.calculateDistance(loc.location.coordinates[1], loc.location.coordinates[0],
                                data._id.location.coordinates[1], data._id.location.coordinates[0], "K") * 1000;
                            var totalRatings = 0;

                            await reviewModel.find({ _id: { $in: data._id.reviews } }).select('status rating').then((rv) => {
                                data._id.reviews = rv
                            }).catch(err => {
                                reject(res.json({ code: code.internalError, message: msg.internalServerError }))
                            })

                            let reviews_details = data._id.reviews.filter(function (result) {

                                if (result.status == status.active) {
                                    totalRatings += result.rating
                                    return result
                                }
                            })
                            if (reviews_details.length > 0) {
                                data._id.ratings = totalRatings / reviews_details.length
                            }
                            else {
                                data._id.ratings = 0
                            }
                            delete data._id.location;
                            delete data._id.reviews;
                            resolve(data);

                        })
                    });
                    final.then((data) => {
                        return res.json({ code: code.ok, message: msg.ok, data: data })
                    })
                }
            })
        }
    })
}
